#!/usr/bin/env perl
#
# Author: petr.danecek@sanger
#

use strict;
use warnings;
use Carp;
use Utils;

my $runner = myRunner->new();
$runner->run();

exit;

#--------------------------------

package myRunner;
use base qw(Runner);
use strict;
use warnings;
use Vcf;

sub new
{
    my ($class,@args) = @_;
    my $self = $class->SUPER::new(@args);

    $$self{do_clean} = 1;
    $$self{debug_chunks} = 0;
    $$self{limits} = { memory=>5_000, runtime=>24*60 };
    $$self{bcftools}    = '/software/vertres/bin-external/bcftools-exp-rc';
    $$self{beagle_jar}  = '/nfs/users/nfs_p/pd3/sandbox/svn/beagle/b4.r1230.jar';
    $$self{beagle_args} = '';
    $$self{java_args} = '';
    $$self{phased_concat_args} = '';
    $$self{memstep} = 2_000;
    $$self{config_version} = '1392388523';
    $$self{redo_beagle} = 0;
    $$self{_sampleconf} = q[
            # For sanity checking that your config file is not obsolete. Update the version key in your 
            #  config file to get rid of the warnings.
            #
            # What changed since version:
            #   1356084361 .. Using "bcftools concat" instead of "vcf-phased-join"
            #
            version  => '] .$$self{config_version}. q[',

            beagle_jar  => '] .$$self{beagle_jar}. q[',
            beagle_args => '',
            java_args   => '',
            bcftools    => '] .$$self{bcftools}. q[',
            phased_concat_args => '] .$$self{phased_concat_args}. q[',

            # The known_vcf (aka -k) and in_vcf (aka -i) file names can contain the string "{CHROM}" which will be expanded 
            #   according to chromosomes listed in the "region" key below. If the key is not defined, glob expansion will
            #   be used to obtain the chromosomes. The VCFs must be tabix indexed. Note that Beagle requires phased
            #   known_vcf and the samples in known_vcf must not overlap the input samples.
            # When known_vcf is set, consider also setting the chunk_by_known key.
            #
            # in_vcf     => '/some/path/chr{CHROM}.vcf.gz',
            # known_vcf  => '/nfs/users/nfs_p/pd3/sandbox/impute2/dec-chr20/Omni25_genotypes_1212_samples_v2.b37.vcf.gz',

            # If supplied, vcf check will be run to evaluate the performance
            # eval_vcf => undef,

            # Number of sites per chunk and in buffer regions. The total number of sites considered is buffer_nsites+chunk_nsites.
            #   The chunks are determined based on the input VCF (-i) unless chunk_by_known is set. 
            buffer_nsites  => 1_000,
            chunk_nsites   => 3_000,
            chunk_by_known => 0,

            # Indels usually have high false positives rate
            exclude_multiallelic_indels => 0,

            # If unset, imputed sites from known_vcf which are not present in in_vcf will not be printed on output. 
            #   This is useful when performing genotype refinement and the number of sites should stay unchanged.
            do_impute  => 1,

            # No imputation or genotype, only genotype refinement. Run with gt=
            #   and leaves off gl=. Consider adding to 'beagle_args' the
            #   options gprobs=false (no posterior genotype probabilities) or
            #   phase-its= to increase phasing accuracy (the default is phase-its=5).
            do_phasing => 0,

            # Create whole-genome VCF? This can produce *huge* files for thousands of samples
            merge_chroms   => 0,

            # Regions to impute, the chunks must be sorted by chromosomal position or else the resulting VCF will not
            #   be sorted. By default, the whole VCF is imputed.
            # region => [ '1:159000000-161000000', '1:62000000-64000000', '2' ],

            limits   => { memory=>10_000, runtime=>24*60 },
            # How much memory should be given to Beagle in the next run if it fails because of out-of-memory error?
            #   Smaller step saves farm node's memory but can result in multiple runs (note that it can take
            #   considerable amount of CPU time before the memory is exhausted). On the other hand, bigger step may 
            #   block free CPUs on multi-core nodes by reserving too much memory.
            memstep  => '] .$$self{memstep}. q[',   # the step for increasing memory limit

            save_beagle_outputs => 0,   # If set, raw output files from beagle will not be removed (for debugging)

            do_clean => 1,         # Remove runner's temporary files
    ]."\n";

    $$self{usage} .= 
        "Usage: run-beagle\n" .
        "Options:\n" .
        "   -i, --impute-vcf <file>             The target VCF file to be imputed or genotypes refined\n" .
        "   -m, --mrProper                      Clean all intermediate files, including Impute2 output files, leaving only top-level VCFs\n" .
        "   -o, --outdir <dir>                  Output directory\n" .
        "   -r, --region <chr|chr:from-to>      Run imputation in the given region only\n" .
        "\n";

    return $self;
}

sub parse_args
{
    my ($self) = @_;
    while (defined(my $arg=shift(@ARGV)))
    {
        if ( $arg eq '-m' or $arg eq '--mrProper' ) { $$self{mrProper}=1; next; }
        if ( $arg eq '-r' or $arg eq '--region' ) { $$self{region}=shift(@ARGV); next; }
        if ( $arg eq '-i' or $arg eq '--impute-vcf' ) { $$self{in_vcf}=shift(@ARGV); next; }
        if ( $arg eq '-k' or $arg eq '--known-vcf' ) { $$self{known_vcf}=shift(@ARGV); next; }
        if ( $arg eq '-o' or $arg eq '--outdir' ) { $$self{outdir}=shift(@ARGV); next; }
        $self->throw();
    }

    if ( !exists($$self{outdir}) ) { $self->throw("Missing the -o option.\n"); }
    if ( !exists($$self{in_vcf}) ) { $self->throw("Missing the -i option.\n"); }
    $$self{chunk_file} = "$$self{outdir}/chunks.txt";
    if ( $$self{mrProper} )
    {
        $self->mrProper($$self{outdir});
        $self->all_done;
    }
    if ( !exists($$self{version}) or $$self{version} ne $$self{config_version} )
    {
        $self->warn("Warning: Your config file may be out of date, the latest version key is \"$$self{config_version}\". Please run with +sampleconf to see what changed.\n");
    }
    if ( exists($$self{known_vcf}) && !($$self{known_vcf}=~/.gz$/) )
    {
        $self->warn("The known_vcf should be bgzipped and tabix indexed. Hopefully you know what you're doing?\n");
    }
    if ( exists($$self{buffer_region}) or exists($$self{chunk_size}) )  
    { 
        $self->throw("The keys buffer_region and chunk_size are deprecated, please use buffer_nsites and chunk_nsites instead."); 
    }
    if ( !exists($$self{buffer_nsites}) ) 
    { 
        $self->throw("Missing the key buffer_nsites"); 
    }
    if ( !exists($$self{chunk_nsites}) ) 
    { 
         $self->throw("Missing the key chunk_nsites");
    }
    if ( $$self{chunk_by_known} && !exists($$self{known_vcf}) )
    {
        $self->throw("Expected the key \"known_vcf\" with \"chunk_by_known\".\n");
    }
}

sub main
{
    my ($self) = @_;
    $self->parse_args();
    $self->save_config();

    my $outdir = $$self{outdir};

    my $chunks = $self->read_chunks();
    for my $chunk (@$chunks)
    {
        $self->set_limits(%{$$self{limits}}) unless !exists($$self{limits});
        $self->spawn('beagle',"$outdir/$$chunk[0]/$$chunk[1]-$$chunk[2].done","$outdir/$$chunk[0]",$chunk);
    }
    $self->wait;

    # Convert to VCFs and concat
    if ( $$self{merge_chroms} ) 
    { 
        $self->set_limits(%{$$self{limits}},memory=>undef) unless !exists($$self{limits});
        $self->spawn('concat_vcfs',"$outdir/merged.vcf.gz",$chunks);
    }
    else
    {
        $self->set_limits(%{$$self{limits}},memory=>undef) unless !exists($$self{limits});
        my @chroms = $self->get_chroms($chunks);
        for my $chr (@chroms)
        {
            $self->spawn('concat_vcfs',"$outdir/$chr.vcf.gz",$chunks,$chr);
        }
    }
    $self->wait; 
    $self->set_limits(runtime=>undef);

    # Run performance stats and clean
    $self->spawn('runtime_stats',"$outdir/runtime");
    $self->wait;
    $self->clean($outdir) unless !$$self{do_clean};

    $self->all_done;
}

sub mrProper
{
    my ($self,$outdir) = @_;
    my $chunks = $self->read_chunks();
    my %chroms = ();
    for my $chunk (@$chunks) { $chroms{$$chunk[0]} = 1; }
    for my $chr (keys %chroms)
    {
        $self->cmd("rm -rf $outdir/$chr");
    }
    $self->SUPER::clean($outdir);
}

sub runtime_stats
{
    my ($self,$outfile) = @_;
    $self->cmd("mkdir -p $outfile.part");
    $self->cmd("runtime-stats $$self{outdir} -p $outfile.part/graph > $outfile.part/stats.txt");
    rename("$outfile.part",$outfile) or $self->throw("rename $outfile.part $outfile: $!");
}

sub read_chunks
{
    my ($self) = @_;
    if ( !-e $$self{chunk_file} ) 
    { 
        my $in_file = $$self{chunk_by_known} ? $$self{known_vcf} : $$self{in_vcf};
        my @regions = $self->define_regions($in_file);
        for my $region (@regions)
        {
            $self->spawn('define_chunks',"$$self{chunk_file}.$region",$in_file,$region);
        }
        $self->wait;

        $self->cmd("> $$self{chunk_file}.part");
        for my $region (@regions)
        {
            $self->cmd("cat $$self{chunk_file}.$region >> $$self{chunk_file}.part");
        }
        rename("$$self{chunk_file}.part",$$self{chunk_file}) or $self->throw("rename $$self{chunk_file}.part $$self{chunk_file}: $!");
        for my $region (@regions)
        {
            unlink("$$self{chunk_file}.$region");
        }
    }
    open(my $fh,'<',$$self{chunk_file}) or $self->throw("$$self{chunk_file}: $!");
    my @chunks;
    while (my $line=<$fh>)
    {
        chomp($line);
        my @items = split(/\t/,$line);
        push @chunks, [@items];
    }
    close($fh) or $self->throw("$$self{chunk_file}: $!");
    return \@chunks;
}

sub define_chunks
{
    my ($self,$outfile,$in_file,$region) = @_;
    my $tot_sites = $$self{buffer_nsites} + $$self{chunk_nsites};
    my (@chunks,@buffer);
    my $file = $self->expand_chrom($in_file,$region);
    my $cmd  = "tabix $file $region |";
    open(my $in,$cmd) or $self->throw("$cmd: $!");
    while (my $line=<$in>)
    {
        if ( substr($line,0,1) eq '#' ) { next; }
        my $i = index($line,"\t");
        if ( $i<0 ) { $self->throw("Could not parse the line [CHR]: $line"); }
        my $chr = substr($line,0,$i);
        my $j = index($line,"\t",$i+1);
        if ( $j<0 ) { $self->throw("Could not parse the line [POS]: $line"); }
        my $pos = substr($line,$i+1,$j-$i-1);

        if ( @buffer && $buffer[0][0] ne $chr or @buffer>$tot_sites )
        {
            my $chr_from = $buffer[0][0];
            my $pos_from = $buffer[0][1];
            my $pos_to   = $buffer[-1][1];
            my $nout     = @buffer;
            push @chunks, { chr=>$chr_from, from=>$pos_from, to=>$pos_to, n=>$nout };
            if ( $$self{chunk_nsites}<@buffer ) { splice(@buffer,0,$$self{chunk_nsites}); }
            else { @buffer = (); }
        }
        push @buffer, [$chr,$pos];
    }
    if ( @buffer )
    {
        my $chr_from = $buffer[0][0];
        my $pos_from = $buffer[0][1];
        my $pos_to   = $buffer[-1][1];
        my $nout     = @buffer;
        push @chunks, { chr=>$chr_from, from=>$pos_from, to=>$pos_to, n=>$nout };
    }
    close($in) or $self->throw("close $cmd");

    if ( !@chunks ) { $self->throw("No chunks defined?\n"); }
    if ( @chunks>1 && $chunks[-1]{n} < $tot_sites*0.75 )
    {
        my $chunk = splice(@chunks,-1,1);
        $chunks[-1]{to} = $$chunk{to};
        $chunks[-1]{n} += $$chunk{n};
    }

    if ( !($region=~/:/) )
    {
        # The whole chromosome was requested, expand the first and last record
        # to accompany sites not present in whatever file we chunk by (known_vcf or in_vcf).
        $chunks[0]{from} = 0;
        $chunks[-1]{to} = 249250621; # longest chr of human genome
    }

    open(my $out,'>',"$outfile.part") or $self->throw("$outfile.part: $!");
    for my $chunk (@chunks)
    {
        print $out "$$chunk{chr}\t$$chunk{from}\t$$chunk{to}\t$$chunk{n}\n";
    }
    close($out) or $self->throw("close $outfile.part");
    rename("$outfile.part",$outfile);
}

sub get_chroms
{
    my ($self,$regions) = @_;
    my %chroms;
    for my $reg (@$regions) 
    { 
        $chroms{$$reg[0]} = 1; 
    }
    return ( sort keys %chroms );
}

sub expand_chrom
{
    my ($self,$path,$region) = @_;
    if ( !defined $region ) { return $path; }
    $region =~ s/:.*$//;
    $path =~ s/{CHROM}/$region/g;
    return $path;
}

sub define_regions
{
    my ($self,$path) = @_;
    if ( exists($$self{region}) ) { return @{$$self{region}}; }
    if ( !($path=~/{CHROM}/) ) { return ('.'); }
    my $before = $`;
    my $after  = $';
    $path =~ s/{CHROM}/*/;  # only one occurance of {CHROM} is allowed in this implementation
    my @list = glob($path);
    my @regs;
    for my $file (@list)
    {
        $file =~ s{^$before}{};
        $file =~ s{$after$}{};
        push @regs,$file;
    }
    return @regs;
}

sub next_beagle_rec
{
    my ($self,$vcf,$rec, $out_fh,$out_vcf) = @_;
    while (my $x = $vcf->next_data_array)
    {
        if ( $$x[0] ne $$rec[0] ) { $self->throw("Different chromosomes?!  $$x[0] vs $$rec[0]\n"); }
        if ( $$x[1] < $$rec[1] )
        {
            # Out of sync: The beagle site not present in the original VCF
            if ( !$$self{known_vcf} ) { $self->throw("Out of sync? $$x[0]:$$x[1] vs $$rec[0]:$$rec[1]\n"); }
            if ( $$self{do_impute} ) { print $out_fh $out_vcf->format_line($x); }
            next;
        }
        if ( $$x[1] > $$rec[1] ) 
        { 
            # Out of sync: The original VCF line not present in the beagle output
            $vcf->_unread_line($x);
            return undef;
        }
        return $x;
    }
    return undef;
}

sub merge_beagle_vcf 
{
    my ($self,$chr,$from,$to,$ori_fname,$new_fname,$out_fname) = @_;
    my $region  =  "$chr:$from-$to";
    my $ori_vcf = Vcf->new(file=>$ori_fname, region=>$region);
    my $new_vcf = Vcf->new(file=>$new_fname);
    $ori_vcf->parse_header();
    $new_vcf->parse_header();
    my @ori_samples = $ori_vcf->get_samples();
    my @new_samples = $new_vcf->get_samples();
    my %ori_to_new  = ();
    for (my $i=0; $i<@ori_samples; $i++)
    {
        my $smpl = $ori_samples[$i];
        if ( !exists($$new_vcf{has_column}{$smpl}) ) { $ori_to_new{$i+9} = -1; }
        else { $ori_to_new{$i+9} = $$new_vcf{has_column}{$smpl} - 1; }
    }
    my $nsamples = @ori_samples;
    open(my $fh,"| bgzip -c > $out_fname") or $self->throw("| bgzip -c > $out_fname: $!"); 
    $ori_vcf->add_header_line({key=>'INFO', ID=>'AC',Number=>'A',Type=>'Integer',Description=>'Allele count in genotypes'});
    $ori_vcf->add_header_line({key=>'INFO', ID=>'AN',Number=>'1',Type=>'Integer',Description=>'Total number of alleles in called genotypes'});
    $ori_vcf->add_header_line({key=>'FORMAT', ID=>'GL',Number=>'G',Type=>'Float',Description=>'Estimated Genotype Likelihood (Beagle)'});
    $ori_vcf->add_header_line({key=>'FORMAT', ID=>'DS',Number=>'1',Type=>'Float',Description=>'Estimated ALT dose [P(RA) + P(AA)] (Beagle)'});
    print $fh $ori_vcf->format_header();
    my $prev;
    while (my $ori_rec = $ori_vcf->next_data_array())
    {
        if ( $$ori_rec[1] < $from ) { next; }
        if ( $$self{exclude_multiallelic_indels} && $self->is_multiallelic_indel($$ori_rec[3],$$ori_rec[4]) ) { print $fh $ori_vcf->format_line($ori_rec); next; }

        # skip duplicate positions
        if ( defined $prev && $prev eq $$ori_rec[1] ) 
        { 
            print $fh $ori_vcf->format_line($ori_rec);
            next; 
        }
        $prev = $$ori_rec[1];

        my $new_rec = $self->next_beagle_rec($new_vcf, $ori_rec, $fh, $ori_vcf);
        if ( !defined $new_rec ) 
        { 
            # This record was not given to beagle, well, at least it's not present in beagle's output
            print $fh $ori_vcf->format_line($ori_rec);
            next;
        }
        if ( $$new_rec[0] ne $$ori_rec[0] ) { $self->throw("CHR mismatch at $$ori_rec[0]:$$ori_rec[1] .. $$new_rec[3] vs $$ori_rec[3]\n"); }
        if ( $$new_rec[1] ne $$ori_rec[1] ) { $self->throw("POS mismatch at $$ori_rec[0]:$$ori_rec[1] .. $$new_rec[3] vs $$ori_rec[3]\n"); }
        if ( $$new_rec[3] ne $$ori_rec[3] ) { $self->throw("REF mismatch at $$ori_rec[0]:$$ori_rec[1] .. $$new_rec[3] vs $$ori_rec[3]\n"); }
        if ( $$new_rec[4] ne $$ori_rec[4] ) { $self->throw("ALT mismatch at $$ori_rec[0]:$$ori_rec[1] .. $$new_rec[4] vs $$ori_rec[4]\n"); }
        my @alt = split(/,/,$$ori_rec[4]);
        my $nal = 1 + scalar @alt;
        my $igt = $ori_vcf->get_tag_index($$ori_rec[8],'GT',':');
        my $ipl_ori = $ori_vcf->get_tag_index($$ori_rec[8],'PL',':');
        my $igp_ori = $ori_vcf->get_tag_index($$ori_rec[8],'GP',':');
        my $igl_ori = $ori_vcf->get_tag_index($$ori_rec[8],'GL',':');
        my $ids_ori = $ori_vcf->get_tag_index($$ori_rec[8],'DS',':');
        if ( 0 != $new_vcf->get_tag_index($$new_rec[8],'GT',':') ) { $self->throw("Expected GT[:DS:GP, got $$new_rec[8] at $$new_rec[0]:$$new_rec[1]\n"); }
        my $ids_new = $new_vcf->get_tag_index($$new_rec[8],'DS',':');
        my $igp_new = $new_vcf->get_tag_index($$new_rec[8],'GP',':');
        if ( $ids_new!=-1 && $ids_ori==-1 ) { $$ori_rec[8] .= ':DS'; }
        if ( $igp_new!=-1 && $igl_ori==-1 ) { $$ori_rec[8] .= ':GL'; }
        $ids_ori = $ori_vcf->get_tag_index($$ori_rec[8],'DS',':');
        $igl_ori = $ori_vcf->get_tag_index($$ori_rec[8],'GL',':');
        my @ac = ();
        for (my $i=0; $i<$nsamples; $i++)
        {
            my $icol_ori = $i+9;
            my $icol_new = $ori_to_new{$icol_ori};
            if ( $icol_new==-1 ) { next; }  # leave the record unchanged, missing sample (chrY)

            my $gt = $ori_vcf->get_field($$ori_rec[$icol_ori],$igt);
            if ( $ids_new != -1 )
            {
                my $ds = $new_vcf->get_field($$new_rec[$icol_new],$ids_new);
                $$ori_rec[$icol_ori] = $ori_vcf->replace_field($$ori_rec[$icol_ori],$ds,$ids_ori,':');
            }
            if ( index($gt,'/')==-1 && index($gt,'|')==-1 )
            {
                # haploid
                my $new_gt = $new_vcf->get_field($$new_rec[$icol_new],0);
                $new_gt = substr($new_gt,0,1);
                $ac[$new_gt]++;
                $$ori_rec[$icol_ori] = $ori_vcf->replace_field($$ori_rec[$icol_ori],$new_gt,$igt,':');

                if ( $igp_new!=-1 )
                {
                    my @gp = split(/,/, $new_vcf->get_field($$new_rec[$icol_new],$igp_new));
                    my $j = 0;
                    my $k = 1;
                    my @new_gp;
                    while ($j<@gp)
                    {
                        my $val = $gp[$j]!=0 ? log($gp[$j])/2.302585 : -99;
                        if ( $val < -99 ) { $val = -99; }
                        else { $val = sprintf "%.2f", $val; }
                        push @new_gp, $val;
                        $j += ++$k;
                    }
                    $$ori_rec[$icol_ori] = $ori_vcf->replace_field($$ori_rec[$icol_ori],join(',',@new_gp),$igl_ori,':');
                }

                if ( $ipl_ori!=-1 )
                {
                    my @ori_pl = split(/,/,$ori_vcf->get_field($$ori_rec[$icol_ori], $ipl_ori));
                    my @new_pl;
                    for (my $j=0; $j<$nal; $j++)
                    {
                        push @new_pl, $ori_pl[$j];
                    }
                    $$ori_rec[$icol_ori] = $ori_vcf->replace_field($$ori_rec[$icol_ori],join(',',@new_pl),$ipl_ori,':');
                }
            }
            else
            {
                # diploid
                my $new_gt = $new_vcf->get_field($$new_rec[$icol_new],0);
                my @gt = $new_vcf->split_gt($new_gt);
                if ( scalar @gt !=2 ) { $self->throw("Uh: $new_gt, $$ori_rec[0]:$$ori_rec[1]  [$icol_ori][$icol_new]\n"); }
                for my $gt (@gt) { $ac[$gt]++; }
                $$ori_rec[$icol_ori] = $ori_vcf->replace_field($$ori_rec[$icol_ori],$new_gt,0,':');

                if ( $igp_new!=-1 )
                {
                    my @new_gp = split(/,/, $new_vcf->get_field($$new_rec[$icol_new],$igp_new));
                    for (my $j=0; $j<@new_gp; $j++)
                    {
                        my $val = $new_gp[$j]!=0 ? log($new_gp[$j])/2.302585 : -99;
                        if ( $val < -99 ) { $val = -99; }
                        else { $val = sprintf "%.2f", $val; }
                        $new_gp[$j] = $val;
                    }
                    $$ori_rec[$icol_ori] = $ori_vcf->replace_field($$ori_rec[$icol_ori],join(',',@new_gp),$igl_ori,':');
                }
            }
        }
        my $an = 0;
        for my $ac (@ac) { $an += $ac ? $ac : 0; }
        shift(@ac);
        my $ac = scalar @ac ? join(',',@ac) : undef;
        $$ori_rec[7] = $ori_vcf->add_info_field($$ori_rec[7],'AC'=>$ac,'AN'=>$an);
        print $fh $ori_vcf->format_line($ori_rec);
    }
    close($fh);
}

sub is_multiallelic_indel
{
    my ($self,$ref,$alt) = @_;
    my $i = index($alt,',');
    if ( $i==-1 ) { return 0; }
    if ( length($ref)>1 or $i>1 ) { return 1; }
    return 0;
}

sub haploid_to_diploid
{
    my ($self,$vcf,$rec) = @_;

    my $igt = $vcf->get_tag_index($$rec[8],'GT',':');
    my $ipl = $vcf->get_tag_index($$rec[8],'PL',':');
    if ( $igt==-1 ) { $self->throw("GT not present in $$vcf{file} at $$rec[0]:$$rec[1]\n"); }
    my @alt = split(/,/,$$rec[4]);
    my $nal = 1 + scalar @alt;
    my $ncols = @{$$vcf{columns}};
    my $nonmiss_gts = $$self{nonmiss_gts};
    for (my $i=9; $i<$ncols; $i++)
    {
        my $gt = $vcf->get_field($$rec[$i], $igt);

        # detect non-missing genotypes
        if ( $gt ne './.' && $gt ne '.' ) { $$nonmiss_gts[$i-9]++; }

        if ( index($gt,'/')>=0 || index($gt,'|')>=0 ) { next; }    # diploid
        my $new_gt = "$gt/$gt";
        $$rec[$i] = $vcf->replace_field($$rec[$i], $new_gt, $igt, ':');

        if ( $ipl != -1 )
        {
            my $pl  = $vcf->get_field($$rec[$i], $ipl);
            my @pls = split(/,/, $pl);

            if ( @pls!=$nal ) { $self->throw("Wrong number of PL fields? col=$i, nal=$nal, $pl=$pl: ", join("\n",@$rec)); }

            my @new_pl;
            for (my $j=0; $j<$nal; $j++)
            {
                for (my $k=0; $k<$j; $k++) { push @new_pl, 999; }  # set likelihoods of hets to zero
                    push @new_pl, $pls[$j];
            }
            $$rec[$i] = $vcf->replace_field($$rec[$i], join(',',@new_pl), $ipl, ':');
        }
    }
}

sub create_vcf_chunk
{
    my ($self,$in_vcf,$out_vcf,$chr,$from,$to) = @_;
    my $vcf = Vcf->new(file=>$in_vcf, region=>"$chr:$from-$to");
    $vcf->parse_header();

    open(my $out,"| gzip -c > $out_vcf") or $self->throw("gzip -c > $out_vcf: $!");
    print $out $vcf->format_header();

    $$self{nonmiss_gts} = [];
    my $prev;
    while (my $rec = $vcf->next_data_array())
    {
        if ( $$rec[1] < $from ) { next; }
        if ( $$self{exclude_multiallelic_indels} && $self->is_multiallelic_indel($$rec[3],$$rec[4]) ) { next; }

        # skip duplicate positions
        if ( defined $prev && $prev eq $$rec[1] ) { next; }
        $prev = $$rec[1];

        $self->haploid_to_diploid($vcf, $rec);
        print $out $vcf->format_line($rec);
    }
    $vcf->close();
    close($out) or error("close gzip -c > $out_vcf");

    # Exclude samples with all genotypes missing - chrY
    my (@samples) = $vcf->get_samples();
    my @nonmiss_smpls = ();
    for (my $i=0; $i<@samples; $i++) { if ( $$self{nonmiss_gts}[$i] ) { push @nonmiss_smpls, $samples[$i]; } }
    if ( @nonmiss_smpls==@samples ) { return; }
    open($out,'>',"$out_vcf.samples") or $self->throw("$out_vcf.samples: $!");
    print $out join("\n",@nonmiss_smpls), "\n";
    close($out) or $self->throw("close failed: $out_vcf.samples");
    $self->cmd("gunzip -c $out_vcf | $$self{bcftools} view -S $out_vcf.samples | gzip -c > $out_vcf.x");
    rename("$out_vcf.x",$out_vcf) or $self->throw("rename $out_vcf.x $out_vcf: $!");
    unlink("$out_vcf.samples");
}

sub beagle
{
    my ($self,$outfile,$outdir,$chunk) = @_;
    my $prefix = "$outdir/$$chunk[1]-$$chunk[2]";
    my $chr  = $$chunk[0];
    my $from = $$chunk[1];
    my $to   = $$chunk[2];
    my $in_vcf    = $self->expand_chrom($$self{in_vcf},$chr);
    my $known_vcf = exists($$self{known_vcf}) ? $self->expand_chrom($$self{known_vcf},$chr) : undef;

    if ( !-e "$prefix.vcf.gz" or $$self{redo_beagle} )
    {
        $self->cmd(qq[mkdir -p $outdir]);
        my $mem = $self->get_limits('memory') * 0.8;
        if ( $mem<=0 ) { $mem = 500; }
        my $known = defined $known_vcf ? "ref=$known_vcf" : '';
        if ( $known ne '' )
        {
            $known .= $$self{do_impute} ? ' impute=true' : ' impute=false';
        }
        my $action = $$self{do_phasing} ? "gt=$prefix.in.vcf.gz" : "gl=$prefix.in.vcf.gz";
        $self->create_vcf_chunk($in_vcf,"$prefix.in.vcf.gz",$chr,$from,$to);
        $self->java_cmd(qq[java -Xms${mem}m -Xmx${mem}m $$self{java_args} -jar $$self{beagle_jar} $$self{beagle_args} $known $action out=$prefix.part >>$outfile.o],"$outfile.e");
        if ( -s "$outfile.e" ) { $self->throw("Expected empty error file: $outfile.e"); }
        rename("$prefix.part.vcf.gz","$prefix.vcf.gz") or $self->throw("rename $prefix.part.vcf.gz $prefix.vcf.gz: $!");
        unlink("$prefix.in.vcf.gz");
    }
    $self->merge_beagle_vcf($chr,$from,$to,$in_vcf,"$prefix.vcf.gz","$prefix.vcf.gz.part");
    if ( $$self{save_beagle_outputs} )
    {
        rename("$prefix.vcf.gz","$prefix.raw-beagle.vcf.gz"); 
    }
    else
    {
        unlink("$prefix.vcf.gz");   # delete raw beagle output
    }
    $self->tabix_part("$prefix.vcf.gz");
    rename("$prefix.vcf.gz.part","$prefix.vcf.gz");
    $self->cmd(qq[touch $outfile]);
}

sub concat_vcfs
{
    my ($self,$outfile,$chunks,$chr) = @_;
    open(my $fh,'>',"$outfile.list") or $self->throw("$outfile.list: $!");
    for my $chunk (@$chunks)
    {
        if ( defined $chr && $$chunk[0] ne $chr ) { next; }
        my $file = "$$self{outdir}/$$chunk[0]/$$chunk[1]-$$chunk[2].vcf.gz";
        print $fh $file, "\n";
    }
    close($fh);
    $self->cmd(qq[$$self{bcftools} concat $$self{phased_concat_args} -lf $outfile.list -Oz > $outfile.part]);
    $self->tabix_part($outfile);

    if ( !defined($$self{eval_vcf}) )
    {
        rename("$outfile.part",$outfile);
        return;
    }

    rename("$outfile.part","$outfile.tmp.vcf.gz");
    rename("$outfile.tbi","$outfile.tmp.vcf.gz.tbi");
    my $args = defined $chr ? "-r $chr" : '';
    my $eval_vcf = $self->expand_chrom($$self{eval_vcf},$chr);
    $self->cmd(qq[$$self{bcftools} stats $args -s - $eval_vcf $outfile.tmp.vcf.gz > $outfile.vchk]);
    rename("$outfile.tmp.vcf.gz.tbi","$outfile.tbi");
    rename("$outfile.tmp.vcf.gz","$outfile");
}

sub tabix_part
{
    my ($self,$vcf) = @_;
    $self->cmd("tabix -p vcf -f $vcf.part");
    rename("$vcf.part.tbi","$vcf.tbi");
}

sub save_config
{
    my ($self) = @_;
    my $src = $$self{_config};
    my $dst = "$$self{outdir}/beagle.conf";
    if ( -e $dst && (stat($src))[9] <= (stat($dst))[9] ) { return; }
    if ( !-d $$self{outdir} ) { $self->cmd("mkdir -p $$self{outdir}"); }
    open(my $fh,'>',$dst) or $self->throw("$dst: $!");
    my $about = $$self{_about};
    $about =~ s/\n/\n# /g;
    print $fh "# $about";
    close($fh);
    $self->cmd("cat $src >> $dst");
}

sub cmd
{
    my ($self,$cmd) = @_;
    return Utils::CMD($cmd,{verbose=>1});
}
sub java_cmd
{
    my ($self,$cmd,$err_file) = @_;

    print STDERR "$cmd 2>$err_file\n";
    if ( -e $err_file ) { `cat $err_file >> $err_file.prev`; unlink($err_file); }

    `$cmd 2>$err_file`;
    if ( ! $? ) { return; } # finished OK

    # something went wrong
    my $out_of_memory = 0;
    open(my $fh,'<',$err_file) or $self->throw("$err_file: $!");
    while (my $line=<$fh>)
    {
        if ( $line=~/java.lang.OutOfMemoryError/ ) { $out_of_memory = 1; last; }
        if ( $line=~/Could not create the Java virtual machine/ ) { $out_of_memory = 1; last; }
    }
    close($fh);
    if ( !$out_of_memory ) { $self->throw("The command failed: $cmd\n"); }

    # out of memory: tell the runner to use more memory next time
    my $mem = $self->get_limits('memory') + $$self{memstep};
    $self->set_limits(memory=>$mem);

    $self->throw("Memory limit exceeded, increasing the memory limit for the next run to $mem. The command was:\n$cmd\n");
}


